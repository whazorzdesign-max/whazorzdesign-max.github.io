To take the 2.5D Sandwich to the next level, we are moving away from flat stacks to a Parabolic Curvature Engine.Instead of simple flat planes, we will modify the BufferGeometry of each slice so that it bends slightly toward the viewer. This mimics the look of a high-end acrylic standee or a curved "3D" sticker.Full Code: The Curved 2.5D Sandwich GeneratorThis version adds a Curvature slider. It works by mathematically remapping the z position of every vertex in the plane based on its distance from the center ($z = x^2 \cdot curve$).HTML<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Curved 2.5D Studio</title>
    
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <style>
        :root { --accent: #00f2ff; --panel-bg: rgba(0, 0, 0, 0.9); --glass: rgba(255, 255, 255, 0.05); --font: 'Inter', sans-serif; }
        body, html { margin: 0; padding: 0; height: 100%; background: #000; color: #fff; font-family: var(--font); overflow: hidden; }
        #studio-layout { display: grid; grid-template-columns: 320px 1fr 320px; height: 100vh; width: 100vw; }
        #viewport-container { position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; background: radial-gradient(circle at center, #111 0%, #000 100%); }
        .sidebar { background: var(--panel-bg); backdrop-filter: blur(30px); padding: 25px; display: flex; flex-direction: column; gap: 20px; border-right: 1px solid #222; z-index: 10; }
        .sidebar.right { border-right: none; border-left: 1px solid #222; }
        h2 { font-size: 11px; letter-spacing: 4px; color: var(--accent); text-transform: uppercase; margin: 0; opacity: 0.9; }
        .control-block { background: var(--glass); border: 1px solid #333; padding: 15px; border-radius: 12px; }
        label { display: block; font-size: 10px; text-transform: uppercase; color: #888; margin-bottom: 8px; letter-spacing: 1.5px; }
        input[type="text"] { width: 100%; background: #050505; border: 1px solid #333; color: #fff; padding: 12px; border-radius: 6px; margin-bottom: 10px; box-sizing: border-box; font-family: monospace; }
        input[type="range"] { width: 100%; accent-color: var(--accent); cursor: pointer; }
        .btn-generate { width: 100%; background: linear-gradient(135deg, #00f2ff, #0062ff); color: #000; border: none; padding: 14px; border-radius: 6px; font-weight: 900; font-size: 12px; cursor: pointer; text-transform: uppercase; transition: 0.4s; }
        .btn-generate:hover { transform: scale(1.02); box-shadow: 0 0 40px rgba(0, 242, 255, 0.3); }
        #hud-status { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); font-family: monospace; font-size: 11px; color: #555; letter-spacing: 3px; }
        .curved-badge { color: #ff00ff; border: 1px solid #ff00ff; padding: 2px 6px; border-radius: 4px; font-size: 9px; margin-left: 10px; vertical-align: middle; }
    </style>
</head>
<body>

<div id="studio-layout">
    <div class="sidebar">
        <h2>Neural Core</h2>
        <div class="control-block">
            <label>Character Identity</label>
            <input type="text" id="name" placeholder="Name..." value="">
            <input type="text" id="realm" placeholder="Realm..." value="">
            <button class="btn-generate" onclick="window.fetchChar()">Process Curved Render</button>
        </div>
        
        <h2>Curvature Engine <span class="curved-badge">v2.0</span></h2>
        <div class="control-block">
            <label>Arc Intensity (Bend)</label>
            <input type="range" id="curvature" min="-0.5" max="0.5" step="0.05" value="0.2">
            <label>Layer Density</label>
            <input type="range" id="layers" min="5" max="40" step="1" value="20">
            <label>Slice Spacing</label>
            <input type="range" id="spread" min="0.01" max="0.1" step="0.005" value="0.03">
        </div>
    </div>

    <div id="viewport-container">
        <div id="hud-status">READY // GEOMETRY: CURVED_S_MESH</div>
    </div>

    <div class="sidebar right">
        <h2>Visual FX</h2>
        <div class="control-block">
            <label>Metalness (Reflect)</label>
            <input type="range" id="metal" min="0" max="1" step="0.1" value="0.4">
            <label>Light Shift X</label>
            <input type="range" id="lightX" min="-15" max="15" value="5">
            <label>Scale</label>
            <input type="range" id="scale" min="0.5" max="2.5" step="0.1" value="1.2">
        </div>
        <div style="margin-top:auto; font-size:10px; color:#333; text-align:right;">MORPH_Z_COORD // ENABLED</div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer, charGroup, pointLight;
    const viewport = document.getElementById('viewport-container');
    const PROXY = "https://api.allorigins.win/raw?url=";
    const WORKER_URL = "https://my-worker.whazorz.workers.dev/"; 
    let currentTex = null;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(40, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
        camera.position.set(0, 0, 9);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        viewport.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        pointLight = new THREE.PointLight(0xffffff, 200, 50);
        pointLight.position.set(5, 5, 10);
        pointLight.castShadow = true;
        scene.add(pointLight);

        charGroup = new THREE.Group();
        scene.add(charGroup);

        animate();
    }

    window.fetchChar = async function() {
        const name = document.getElementById('name').value;
        const realm = document.getElementById('realm').value;
        const status = document.getElementById('hud-status');
        if(!name || !realm) return;

        status.innerHTML = `<span style="color:var(--accent)">CALCULATING BEND VECTORS...</span>`;
        try {
            const res = await fetch(`${WORKER_URL}?name=${encodeURIComponent(name)}&realm=${encodeURIComponent(realm)}`);
            const data = await res.json();
            const asset = data.media.assets.find(a => a.key === "main-raw") || data.media.assets[0];
            
            new THREE.TextureLoader().setCrossOrigin('anonymous').load(PROXY + encodeURIComponent(asset.value), (tex) => {
                currentTex = tex;
                buildCurvedSandwich();
                status.innerText = "BEND RENDER SUCCESSFUL";
            });
        } catch(e) { status.innerText = "ERROR: LINK_FAILURE"; }
    }

    function buildCurvedSandwich() {
        if(!currentTex) return;
        while(charGroup.children.length > 0) charGroup.remove(charGroup.children[0]);

        const layerCount = parseInt(document.getElementById('layers').value);
        const spread = parseFloat(document.getElementById('spread').value);
        const curv = parseFloat(document.getElementById('curvature').value);

        for (let i = 0; i < layerCount; i++) {
            // High segment count (32x32) is required for smooth bending
            const geometry = new THREE.PlaneGeometry(4, 5, 32, 32);
            
            // --- THE BENDING MATH ---
            const pos = geometry.attributes.position;
            for (let j = 0; j < pos.count; j++) {
                const x = pos.getX(j);
                const y = pos.getY(j);
                // Parabolic Curve formula: Z increases as X moves away from 0
                const zOffset = (x * x) * curv;
                pos.setZ(j, zOffset);
            }
            geometry.computeVertexNormals(); 

            const darkness = 1 - (i * 0.02);
            const material = new THREE.MeshStandardMaterial({ 
                map: currentTex, 
                transparent: true, 
                alphaTest: 0.5,
                side: THREE.DoubleSide,
                metalness: parseFloat(document.getElementById('metal').value),
                roughness: 0.3,
                color: new THREE.Color(darkness, darkness, darkness)
            });

            const slice = new THREE.Mesh(geometry, material);
            slice.position.z = (i - layerCount / 2) * spread;
            if(i === 0 || i === layerCount-1) slice.castShadow = true;
            charGroup.add(slice);
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        if(charGroup && charGroup.children.length > 0) {
            const scale = document.getElementById('scale').value;
            charGroup.scale.set(scale, scale, scale);
            
            const time = Date.now() * 0.001;
            charGroup.rotation.y = Math.sin(time * 0.5) * 0.6; // Wider sway to show curve
            charGroup.position.y = Math.sin(time) * 0.1;

            // Live-rebuild check for sliders
            const currentLayers = charGroup.children.length;
            if(currentLayers !== parseInt(document.getElementById('layers').value)) buildCurvedSandwich();
        }
        pointLight.position.x = document.getElementById('lightX').value;
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = viewport.clientWidth / viewport.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
    });

    init();
</script>
</body>
</html>