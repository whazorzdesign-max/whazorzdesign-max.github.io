To achieve a "blurry interior" without losing the sharp silhouette, we use a technique where the alphaTest remains high (to keep the crust sharp) while the internal layers are slightly offset and multiplied to simulate a Depth of Field or "motion blur" look.

I have updated the buildSandwich logic. It now applies a "Neural Blur" effect where the inner slices have lower opacity and slight random offsets, creating a soft volume inside the sharp outer shells.

HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 2.5D Studio // Sharp Silhouette Blur</title>
    
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <style>
        :root { 
            --accent: #00f2ff; 
            --panel-bg: rgba(0, 0, 0, 0.9);
            --glass: rgba(255, 255, 255, 0.05);
            --font: 'Inter', 'Segoe UI', sans-serif;
        }

        body, html { margin: 0; padding: 0; height: 100%; background: #020202; color: #fff; font-family: var(--font); overflow: hidden; }
        #studio-layout { display: grid; grid-template-columns: 300px 1fr 300px; height: 100vh; width: 100vw; background: radial-gradient(circle at center, #0a0a0a 0%, #000 100%); }
        #viewport-container { position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; border-left: 1px solid #111; border-right: 1px solid #111; }
        canvas { outline: none; }
        .sidebar { background: var(--panel-bg); backdrop-filter: blur(20px); padding: 25px; display: flex; flex-direction: column; gap: 20px; z-index: 10; border-right: 1px solid rgba(255,255,255,0.05); }
        .sidebar.right { border-right: none; border-left: 1px solid rgba(255,255,255,0.05); }
        h2 { font-size: 10px; letter-spacing: 3px; color: var(--accent); margin: 0; text-transform: uppercase; opacity: 0.8; }
        .control-block { background: var(--glass); border: 1px solid rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; }
        label { display: block; font-size: 9px; text-transform: uppercase; color: #666; margin-bottom: 8px; letter-spacing: 1px; }
        input[type="text"] { width: 100%; background: #000; border: 1px solid #222; color: #fff; padding: 10px; border-radius: 4px; margin-bottom: 10px; box-sizing: border-box; font-family: monospace; }
        input[type="range"] { width: 100%; accent-color: var(--accent); cursor: pointer; background: transparent; }
        .btn-generate { width: 100%; background: linear-gradient(45deg, #00f2ff, #0062ff); color: #000; border: none; padding: 12px; border-radius: 4px; font-weight: 800; font-size: 11px; cursor: pointer; text-transform: uppercase; transition: 0.3s; box-shadow: 0 0 20px rgba(0, 242, 255, 0.2); }
        .btn-generate:hover { transform: translateY(-2px); box-shadow: 0 0 30px rgba(0, 242, 255, 0.4); }
        #hud-status { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-family: monospace; font-size: 10px; color: #444; z-index: 5; text-transform: uppercase; letter-spacing: 2px; }
    </style>
</head>
<body>

<div id="studio-layout">
    <div class="sidebar">
        <h2>Neural Import</h2>
        <div class="control-block">
            <label>Biological Identity</label>
            <input type="text" id="name" placeholder="Character Name...">
            <input type="text" id="realm" placeholder="Realm Name...">
            <button class="btn-generate" onclick="window.fetchChar()">Construct Sandwich</button>
        </div>
        
        <h2>2.5D Parameters</h2>
        <div class="control-block">
            <label>Slice Count</label>
            <input type="range" id="layers" min="10" max="60" step="1" value="40">
            <label>Neural Blur Depth</label>
            <input type="range" id="spread" min="0.01" max="0.1" step="0.005" value="0.03">
            <label>Mesh Scale</label>
            <input type="range" id="scale" min="0.5" max="2.5" step="0.1" value="1.2">
        </div>
    </div>

    <div id="viewport-container">
        <div id="hud-status">SYSTEM.IDLE // SHARP_SILHOUETTE_ACTIVE</div>
    </div>

    <div class="sidebar right">
        <h2>Light Studio</h2>
        <div class="control-block">
            <label>Intensity</label>
            <input type="range" id="lightIntensity" min="0" max="200" value="120">
            <label>Orbit X</label>
            <input type="range" id="lightX" min="-10" max="10" value="5">
        </div>

        <h2>Environment</h2>
        <div class="control-block">
            <label>Ambient Occlusion</label>
            <input type="range" id="ambient" min="0" max="5" step="0.1" value="1.8">
            <button onclick="window.resetLight()" style="width:100%; background:transparent; border:1px solid #333; color:#888; padding:8px; font-size:9px; cursor:pointer; border-radius:4px;">Recalibrate</button>
        </div>
        <p style="font-size: 8px; color: #444; margin-top: auto;">V1.4 // BLUR_INTERIOR_SHARP_EDGE</p>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer, charGroup, pointLight, ambientLight;
    const viewport = document.getElementById('viewport-container');
    const PROXY = "https://api.allorigins.win/raw?url=";
    const WORKER_URL = "https://my-worker.whazorz.workers.dev/"; 
    let currentTexture = null;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(40, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
        camera.position.set(0, 0, 8);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        viewport.appendChild(renderer.domElement);

        ambientLight = new THREE.AmbientLight(0xffffff, 1.8);
        scene.add(ambientLight);

        pointLight = new THREE.PointLight(0xffffff, 120);
        pointLight.position.set(5, 5, 5);
        pointLight.castShadow = true;
        scene.add(pointLight);

        charGroup = new THREE.Group();
        charGroup.rotation.y = 0.4; 
        scene.add(charGroup);

        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(20, 20),
            new THREE.ShadowMaterial({ opacity: 0.3 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -3;
        floor.receiveShadow = true;
        scene.add(floor);

        render();
    }

    window.fetchChar = async function() {
        const name = document.getElementById('name').value.trim();
        const realm = document.getElementById('realm').value.trim();
        if(!name || !realm) return;

        try {
            const res = await fetch(`${WORKER_URL}?name=${encodeURIComponent(name)}&realm=${encodeURIComponent(realm)}&region=eu`);
            const data = await res.json();
            const asset = data.media.assets.find(a => a.key === "main-raw") || data.media.assets[0];
            loadTextureAndBuild(PROXY + encodeURIComponent(asset.value));
        } catch(e) { console.error(e); }
    }

function loadTextureAndBuild(url) {
        const loader = new THREE.TextureLoader();
        loader.setCrossOrigin('anonymous');
        
        // Add a timestamp to the URL to bypass proxy caching, 
        // which can sometimes trigger timeouts on old/broken links.
        const cacheBuster = url.includes('?') ? `&t=${Date.now()}` : `?t=${Date.now()}`;
        
        loader.load(
            url + cacheBuster, 
            (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                currentTexture = texture;
                buildSandwich();
            },
            undefined, // onProgress
            (err) => {
                console.error("Texture Load Error:", err);
                document.getElementById('hud-status').innerText = "ERROR: PROXY_TIMEOUT_408";
            }
        );
    }

    function buildSandwich() {
        if(!currentTexture) return;
        while(charGroup.children.length > 0) charGroup.remove(charGroup.children[0]);

        const layerCount = parseInt(document.getElementById('layers').value);
        const spread = parseFloat(document.getElementById('spread').value);

        for (let i = 0; i < layerCount; i++) {
            const geometry = new THREE.PlaneGeometry(4, 5);
            
            // i=0 is front (Sharp), i=layerCount-1 is back (Sharp)
            // Layers in the middle get the "Blur" treatment
            const isEdge = (i === 0 || i === layerCount - 1);
            const depthFactor = Math.abs((i - (layerCount/2)) / (layerCount/2)); // 0 at center, 1 at edges

            const material = new THREE.MeshStandardMaterial({ 
                map: currentTexture, 
                transparent: true, 
                // CRITICAL: High alphaTest keeps the outline sharp even on blurry layers
                alphaTest: 0.6, 
                side: THREE.DoubleSide,
                // Inner layers are more transparent to create a soft volumetric blur look
                opacity: isEdge ? 1.0 : 0.15,
                color: new THREE.Color(1 - (1-depthFactor)*0.5, 1 - (1-depthFactor)*0.5, 1 - (1-depthFactor)*0.5)
            });

            const slice = new THREE.Mesh(geometry, material);
            
            // Offset logic: Inner layers get slight random jitter to simulate blur
            const jitter = isEdge ? 0 : (Math.random() - 0.5) * 0.02;
            slice.position.set(jitter, jitter, (i - layerCount / 2) * spread);
            
            if (isEdge) slice.castShadow = true;
            charGroup.add(slice);
        }
    }

    function render() {
        requestAnimationFrame(render);
        if(charGroup) {
            charGroup.scale.setScalar(document.getElementById('scale').value);
            if(charGroup.children.length !== parseInt(document.getElementById('layers').value)) buildSandwich();
        }
        pointLight.intensity = document.getElementById('lightIntensity').value;
        pointLight.position.x = document.getElementById('lightX').value;
        ambientLight.intensity = document.getElementById('ambient').value;
        renderer.render(scene, camera);
    }

    window.resetLight = () => {
        document.getElementById('lightIntensity').value = 120;
        document.getElementById('lightX').value = 5;
        document.getElementById('ambient').value = 1.8;
    };

    window.addEventListener('resize', () => {
        camera.aspect = viewport.clientWidth / viewport.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
    });

    init();
</script>
</body>
</html>