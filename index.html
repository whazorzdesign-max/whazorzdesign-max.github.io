<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 2.5D Character Studio</title>
    
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <style>
        :root { 
            --accent: #00f2ff; 
            --panel-bg: rgba(0, 0, 0, 0.9);
            --glass: rgba(255, 255, 255, 0.05);
            --font: 'Inter', 'Segoe UI', sans-serif;
        }

        body, html { margin: 0; padding: 0; height: 100%; background: #020202; color: #fff; font-family: var(--font); overflow: hidden; }

        #studio-layout { display: grid; grid-template-columns: 300px 1fr 300px; height: 100vh; width: 100vw; background: radial-gradient(circle at center, #0a0a0a 0%, #000 100%); }

        #viewport-container { position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; border-left: 1px solid #111; border-right: 1px solid #111; }
        canvas { outline: none; cursor: grab; }
        canvas:active { cursor: grabbing; }

        .sidebar { background: var(--panel-bg); backdrop-filter: blur(20px); padding: 25px; display: flex; flex-direction: column; gap: 20px; z-index: 10; border-right: 1px solid rgba(255,255,255,0.05); }
        .sidebar.right { border-right: none; border-left: 1px solid rgba(255,255,255,0.05); }

        h2 { font-size: 10px; letter-spacing: 3px; color: var(--accent); margin: 0; text-transform: uppercase; opacity: 0.8; }
        
        .control-block { background: var(--glass); border: 1px solid rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; }
        label { display: block; font-size: 9px; text-transform: uppercase; color: #666; margin-bottom: 8px; letter-spacing: 1px; }

        input[type="text"] { width: 100%; background: #000; border: 1px solid #222; color: #fff; padding: 10px; border-radius: 4px; margin-bottom: 10px; box-sizing: border-box; font-family: monospace; }
        input[type="range"] { width: 100%; accent-color: var(--accent); cursor: pointer; background: transparent; }

        .btn-generate { 
            width: 100%; background: linear-gradient(45deg, #00f2ff, #0062ff); 
            color: #000; border: none; padding: 12px; border-radius: 4px; 
            font-weight: 800; font-size: 11px; cursor: pointer; text-transform: uppercase;
            transition: 0.3s; box-shadow: 0 0 20px rgba(0, 242, 255, 0.2);
        }
        .btn-generate:hover { transform: translateY(-2px); box-shadow: 0 0 30px rgba(0, 242, 255, 0.4); }

        #hud-status { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-family: monospace; font-size: 10px; color: #444; z-index: 5; text-transform: uppercase; letter-spacing: 2px; text-align: center; }
        .ai-glow { animation: glow 2s infinite alternate; }
        @keyframes glow { from { opacity: 0.4; color: #fff; } to { opacity: 1; color: var(--accent); } }
    </style>
</head>
<body>

<div id="studio-layout">
    <div class="sidebar">
        <h2>Neural Import</h2>
        <div class="control-block">
            <label>Biological Identity</label>
            <input type="text" id="name" placeholder="Character Name..." value="">
            <input type="text" id="realm" placeholder="Realm Name..." value="">
            <button class="btn-generate" onclick="window.fetchChar()">Construct Sandwich</button>
        </div>
        
        <h2>2.5D Parameters</h2>
        <div class="control-block">
            <label>Slices (Thickness)</label>
            <input type="range" id="layers" min="5" max="40" step="1" value="20">
            <label>Slice Spread</label>
            <input type="range" id="spread" min="0.01" max="0.1" step="0.005" value="0.04">
            <label>Mesh Scale</label>
            <input type="range" id="scale" min="0.5" max="2.5" step="0.1" value="1.2">
        </div>
    </div>

    <div id="viewport-container">
        <div id="hud-status">SYSTEM.IDLE // WAITING_FOR_INPUT</div>
    </div>

    <div class="sidebar right">
        <h2>Light Studio</h2>
        <div class="control-block">
            <label>Light Intensity</label>
            <input type="range" id="lightIntensity" min="0" max="200" value="120">
            <label>Light Position X</label>
            <input type="range" id="lightX" min="-10" max="10" value="5">
        </div>

        <h2>Environment</h2>
        <div class="control-block">
            <label>Ambient Occlusion</label>
            <input type="range" id="ambient" min="0" max="5" step="0.1" value="1.8">
            <button onclick="window.resetLight()" style="width:100%; background:transparent; border:1px solid #333; color:#888; padding:8px; font-size:9px; cursor:pointer; border-radius:4px;">Reset Lighting</button>
        </div>
        <p style="font-size: 8px; color: #444; margin-top: auto;">2.5D SANDWICH ENGINE V1.1 // SHARP_SILHOUETTE_ACTIVE</p>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer, charGroup, pointLight, ambientLight;
    const viewport = document.getElementById('viewport-container');
    
    const PROXY = "https://api.allorigins.win/raw?url=";
    const WORKER_URL = "https://my-worker.whazorz.workers.dev/"; 
    let currentTexture = null;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(40, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
        camera.position.set(0, 0, 8);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        viewport.appendChild(renderer.domElement);

        ambientLight = new THREE.AmbientLight(0xffffff, 1.8);
        scene.add(ambientLight);

        pointLight = new THREE.PointLight(0xffffff, 120);
        pointLight.position.set(5, 5, 5);
        pointLight.castShadow = true;
        scene.add(pointLight);

        charGroup = new THREE.Group();
        scene.add(charGroup);

        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 30),
            new THREE.ShadowMaterial({ opacity: 0.2 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -3.5;
        floor.receiveShadow = true;
        scene.add(floor);

        animate();
    }

    window.fetchChar = async function() {
        const name = document.getElementById('name').value.trim();
        const realm = document.getElementById('realm').value.trim();
        const status = document.getElementById('hud-status');
        
        if(!name || !realm) {
            status.innerText = "ERROR: NAME_OR_REALM_MISSING";
            return;
        }

        status.innerHTML = `<span class="ai-glow">INITIATING MULTI-LAYER SLICE...</span>`;

        try {
            const res = await fetch(`${WORKER_URL}?name=${encodeURIComponent(name)}&realm=${encodeURIComponent(realm)}&region=eu`);
            const data = await res.json();
            
            if(data.error) throw new Error(data.error);

            const asset = data.media.assets.find(a => a.key === "main-raw") || data.media.assets[0];
            const rawUrl = asset.value;
            
            loadTextureAndBuild(PROXY + encodeURIComponent(rawUrl));
            status.innerText = "NEURAL RENDER COMPLETE // 2.5D ACTIVE";
        } catch(e) {
            console.error(e);
            status.innerText = "ERROR: NEURAL_LINK_BROKEN";
        }
    }

    function loadTextureAndBuild(url) {
        const loader = new THREE.TextureLoader();
        loader.setCrossOrigin('anonymous');
        
        loader.load(url, (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace;
            currentTexture = texture;
            buildSandwich();
        });
    }

    function buildSandwich() {
        if(!currentTexture) return;

        while(charGroup.children.length > 0){ 
            charGroup.remove(charGroup.children[0]); 
        }

        const layerCount = parseInt(document.getElementById('layers').value);
        const spread = parseFloat(document.getElementById('spread').value);

        for (let i = 0; i < layerCount; i++) {
            const geometry = new THREE.PlaneGeometry(4, 5);
            
            // Percentage of depth (0 is front, 1 is back)
            const depthFactor = i / (layerCount - 1);
            
            const material = new THREE.MeshStandardMaterial({ 
                map: currentTexture, 
                transparent: true, 
                // Keep alphaTest high (0.5+) to prevent blurred/messy edges on the outline
                alphaTest: 0.55,
                side: THREE.DoubleSide,
                roughness: 0.6,
                metalness: 0.0,
                // Inner "filling" layers are progressively darkened to create fake depth
                color: new THREE.Color(1 - depthFactor * 0.5, 1 - depthFactor * 0.5, 1 - depthFactor * 0.5)
            });

            const slice = new THREE.Mesh(geometry, material);
            
            // Center the stack on Z-axis
            slice.position.z = (i - layerCount / 2) * spread;
            
            // Only the front and back slices handle shadows for clean edges and performance
            if (i === 0 || i === layerCount - 1) {
                slice.castShadow = true;
            }

            charGroup.add(slice);
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        
        if(charGroup && charGroup.children.length > 0) {
            const scale = document.getElementById('scale').value;
            charGroup.scale.set(scale, scale, scale);
            
            const time = Date.now() * 0.001;
            // Auto-sway to show off the sandwich depth
            charGroup.rotation.y = Math.sin(time * 0.5) * 0.5;
            charGroup.position.y = Math.sin(time * 0.8) * 0.05;

            // Rebuild if slider changes count
            const currentLayers = charGroup.children.length;
            const targetLayers = parseInt(document.getElementById('layers').value);
            if(currentLayers !== targetLayers) buildSandwich();
        }

        pointLight.intensity = document.getElementById('lightIntensity').value;
        pointLight.position.x = document.getElementById('lightX').value;
        ambientLight.intensity = document.getElementById('ambient').value;
        
        renderer.render(scene, camera);
    }

    window.resetLight = () => {
        document.getElementById('lightIntensity').value = 120;
        document.getElementById('lightX').value = 5;
        document.getElementById('ambient').value = 1.8;
    };

    window.addEventListener('resize', () => {
        camera.aspect = viewport.clientWidth / viewport.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
    });

    init();
</script>

</body>
</html>